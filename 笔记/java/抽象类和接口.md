抽象类和接口
----------
Java可以创建一种类专门用来当父类，这种类称为“抽象类”。抽象类的作用有点像“模板”，其目的是要设计这一句他的格式类修改并创建新的类。本章讲述抽象类的基本概念以及具有多集成性的接口。

# 抽象类
Java可以创建一种类专门用来当父类，这种类称为“抽象类”。抽象类实际上也是一个类，只是与之前的普通类相比，内部新增了抽象方法。

## 抽象类的基本概念
  抽象方法是只声明未实现的方法，所有的抽象方法必须使用abstract关键字声明，包含抽象方法的类也必须使用abstract class声明。
  抽象类定义规则如下：  
  （1）抽象类和抽象方法都必须用abstract关键字来修饰;   
  （2）抽象类不能直接实例化，也就是不能直接用new关键字去产生对象;  
  （3）抽象类定义时抽象方法只需声明，而不需实现;  
  （4）含有抽象方法的类必须被声明为抽象类，抽象类的子类必须覆写所有的抽象方法后才能被实例化，否则合格子类还是抽象类。

```java
abstract class 类名称{//定义抽象类
    声明数据成员;
    访问权限 返回值的数据类型 方法名称（参数----）{
        //定义一般方法
    }
      abstract 返回值的数据类型 方法名称 （参数----）;//定义抽象方法，在抽象方法里没有定义方法体
}						

```

例如：

```java
abstract class Book{//定义一个抽象类
    private String title = "Java 开发";//属性
    public void print(){//普通方法，有“{”表示有方法体
        System.out.println(title);
    }
    public abstract void fun();//没有方法体，是一个抽象方法
}
```

由上例知：抽象类的定义就是比普通类多了一些抽象方法的定义而已。虽然定义了抽象类，但是抽象类却不能直接使用。

`Book book = new Book();\\错误：Book是抽象的;无法实例化`

  如果说一个类的对象可以被实例化，那么就表示这个对象可以调用类中的属性或者是方法，但是抽象类中存在抽象方法，而抽象方法没有方法体，没有方法体的方法是无法使用。          
所以，对于抽象类的使用原则如下。  
抽象类必须有子类，子类使用extends抽象类，一个子类只能够继承一个抽象类。  
子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法;
如果要想实例化抽象类的对象，则可以使用子类进行对象的向上转型来完成。
- 抽象类的用法（代码AbstractClassDemo.java）

```java
abstract class Person {// 定义一抽象类Persion
	String name; 
	int age;
	String occupation;
	public abstract String String talk();//声明一个抽象方法talk()
}
class Student extends Person{
	public Student(String name,int age,String occupation){
		this.name = name;
		this.age = age;
		this.occupation = occupation;
	}
	public String talk(){//覆写抽象方法talk()
		return "学生---->姓名:"+this.name+",年龄:"+this.age+",职业:"+this.occupation+"!"
	}
}
class Worker extends Person{//Worker 类继承自Person类
	public worker(String name,int age,String occupation){
		this.name = name;
		this.age = age;
		this.occupation = occupation;
	}
	public String talk(){
		return "工人--->姓名:"+this.name+",年龄:"+this.age+",职业:"+this.occupation+"!";
	}
}
class AbstractClassDemo{
	public static void main(String[] args){
		Student s = new Student("张三",20,"学生");
		Worker w = new Worker("李四",30,"工人");
		System.out.println(s.talk());
		System.out.println(w.talk());
	}
}
/*
抽象类的特征
(1)抽象类中可以有构造方法。
  与一般抽象类相同，在抽象类中也可以拥有构造方法，但是这些构造方法必须在子类中被调用，并且子类实例化对象的时候依然满足类继承的关系，先默认调用父类的构造方法，而后再调用子类的构造方法，毕竟抽象类之中还是存在属性的，只不过这个抽象方法无法直接被外部实例化对象的时候所使用。
*/
```
- 抽象类中构造方法的定义使用（代码AbstractConstructor.java）

```java
abstract class Person {// 定义一抽象类Persion
	String name; 
	int age;
	String occupation;
	public Person(String name,int age,String occupation){//定义构造方法
		this.name = name;
		this.age = age;
		this.occupation = occupation;
	}
	public abstract String String talk();//声明一个抽象方法talk()
}
class Student extends Person{
	public Student(String name,int age,String occupation){
		//这里必须明确调用抽象类中的构造方法
		super(name,age,occupation);
	}
	public String talk(){//覆写抽象方法talk()
		return "学生---->姓名:"+this.name+",年龄:"+this.age+",职业:"+this.occupation+"!"
	}
}
class AbstractClassDemo{
	public static void main(String[] args){
		Student s = new Student("张三",20,"学生");
		System.out.println(s.talk());
	}
}
/*
从程序中可以看到，抽象类也可以想普通类一样，有构造方法/一般方法和属性，更重要的是还可以有一些抽象方法，需要子类去实现，而且在抽象类中声明构造方法后，在子类中必须明确调用。
  （2）抽象类不能够使用final定义。使用final定义的类不能有子类，而抽象类使用的时候必须有子类，这是一个矛盾的问题，所以抽象类上不能出现final定义。
  （3）在外部抽象类上无法使用static声明，但是内部抽象类却可以使用static定义，使用static定义的内部抽象类就表示一个外部类。
*/

```

- 验证static定义的内部抽象类（代码StaticInnerAbstractClass.java）

```java
abstract class Book{
	public abstract void();//抽象方法
	static abstract class CD{//静态内部抽象类
		public abstract void get();//抽象方法
	}
}
class javaCD extends Book.CD{//继承抽象类
	public void get(){
		System.out.println("java 学习");
	}
}
public class StsticInnerAbstractClass{
	public static void main(String args[]){
		Book.CD cd = new JavaCD(); //实例化对象
		cd.get();
	}
}
/*
  (4)抽象类之中可以没有抽象方法，但是即便没有抽象方法的抽象类也不能直接在外部通过关键字new实例化
  
*/
```
(1)
## 抽象类一个应用——模板设计模式

  在使用抽象类时，可以将部分逻辑一具体方法和具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方法实现这先后向方法，从而对剩余的逻辑有不同的实现，这就是模板方法模式。
  现在有三类事物机器人、美女、帅哥，这三类四五可以完成的功能如下。
  机器人：吃饭、工作；
  美女：吃饭、跑步、睡觉；
  帅哥：吃饭、工作、跑步、睡觉。

```java
abstract class Action{//表示操作行为
	public static final int EAT = 1;
    public static final int WORK = 2;
    public static final int SLEEP = 5;
    public static final int RUN = 10;
    public abstract void eat();
    public abstract void sleep();
    public abstract void run();
    public abstract void work();
    public void command(int ch){
        switch(ch){
            case EAT:
                this.eat();
               	break;
            case SLEEP:
                this.sleep();
               	break;
            case RUN:
                this.run();
               	break;
            case WORK:
                this.work();
               	break;
            case EAT + WORK:
                this.eat();
                this.work();
               	break;
            case EAT + SLEEP + RUN:
                this.eat();
                this.sleep();
                this.run();
               	break;
            case EAT + SLEEP + RUN + WORK:
                this.eat();
                this.sleep();
                this.run();
                this.work();
               	break;
        }
    }
}
class Robot extends Action{
    public  void eat(){
        System.out.println("为机器人加燃料");
    }
    public  void sleep(){}
    public  void run(){}
    public  void work(){
 		System.out.println("让机器人开始工作");
    }
}
class Woman extends Action{
    public  void eat(){
 		System.out.println("请美女吃饭");
    }
    public  void sleep(){
         System.out.println("让美女睡觉美容");
    }
    public  void run(){
         System.out.println("让美女跑步健身");
    }
    public  void work(){}
}
class Man extends Action{
    public  void eat(){
         System.out.println("帅哥吃早饭、午饭、晚饭");
    }
    public  void sleep(){
         System.out.println("帅哥休闲好以恢复精神和体力");
    }
    public  void run(){
         System.out.println("帅哥通过跑步来锻炼身体");
    }
    public  void work(){
         System.out.println("帅哥为了和美女在一起，要好好工作");
    }
}
public class TemplateMethod{
    public satic void main(String args[]){
        Action actA = new Robot();
        actA.command(Action.EAT);
        actA.command(Action.WORK);
        Action actB = new Woman();
        actB.command(Action.EAT + Action.SLEEP + Action.RUN);
        Action actC = new Man();
        actC.command(Action.EAT + Action.SLEEP + Action.RUN + Action.WORK);
    }
}
/*
此时，如果要想实现制定的操作，只需要将方法按照要求腹泻即可，相当于父类定义出类一个操作模板。实际用的时候也可以在Servlet程序设计上使用。
*/
```

# 接口

接口（interface）是Java所提供的零一种重要技术，是一种特殊的类，它的节后和抽象类非常相似，也具有数据成员与抽象方法，但它与抽象类又有不同，并且Java8中又添加了新特性。

## 接口的基本概念
  接口里的数据成员必须出示话，并且数据成员均为敞亮，常见的是全局变量。
  接口里的方法为abstract，也就是说，接口不能像抽象类一样定义一般的方法，需定义“抽象方法”。
  另外，Java8中为便面在接口中天骄新方法后要修改所有实现类，允许定义默认方法，即default方法，也可以称为Defender方法，或者虚拟拓展方法。
  Default方法是指，在接口内部白喊了一些默认的方法实现（也就是接口中包含方法体，这打破了Java之版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。
  在Java中使用interface关键字来定义一个接口。
  接口定义的语法如下：
	interface 接口名称｛//定义抽象类
		final 数据类型 成员名称 = 常量；//数据成员必粗赋初值
		abstract 返回值的数据类型 方法名称 (参···);//抽象方法，注意在抽象方法里没有定义方法主体
		default 返回值的数据类型 方法名称 （参数···）
		{···方法体···}//默认方法，包含方法体
	｝
定义接口例：
	interface A{//定义一个接口
		public static final String INFO = "Hello World."//全局常量
		public avstract void print();//抽象方法
	}
带默认方法的接口定义例：
	interface B｛//定义一个接口
		public static final String INFO = "Hello World."//全局常量
		public avstract void print();//抽象方法
		default public void otherprint(){//带方法体的默认方法
			System.put.println("default methods");//默认方法的方法体
		}
	｝

虽然有了接口，可是定义的接口A和接口B因里面存在抽象方法，都不能被用户直接使用。

## 接口的使用原则

  使用接口必须遵守如下原则：

- 接口必须有子类，子类依靠implements关键字可以同时实现多个接口

- 接口的子类（如果不是抽象类）则必须腹泻接口之中的全部抽象方法

- 接口可以利用对象多态性，利用老子类实现对象的实例化。

- 接口与一般类一样，本身也具有数据成员与方法，但说一句成员一定要赋初值，且此值不能再背更改，方法也必须是“抽象方法”或default方法。正引文方法出default方法外必须是抽象方法，而没有一般的方法，所以接口定义格式中，抽象方法声明的关键字abstract是可以省略的

- 同理，接口的数据成员升上，因数据成员必须赋初值，且此值不能被更改，所以声明数据成员的关键字final也可省

  

  简写的接口定义例：

  ```java
  interface A{//定义一个接口
      
  }
  ```

  

  

## 接口的作用——工厂设计模式（Factory）

## 接口的作用——代理设计模式（Proxy）

# 抽象类的接口对比

